// Smart IBL Loader V0.17 Alpha
// Tested in Maya 8.5, 2008 and 2009 on Windows XP, Vista 64-bit and MacOS X
// Maya-Version by Volker Heisterberg (volk@renderwahnsinn.de)
// Smart Image Based Ligthing is a interchangeable standard for High Dynamic Range Images by Christian Bloch & Christian Bauer
// For more infos go to http://www.smartIBL.com/ !
// Last changed: 24.10.2008

// Notes:

// - put this script in your maya script folder
// - enter sIBL at the command line
// - if you don«t want to set the folder every time you 
//   restart maya you should define an environment variable called sIBL containg your library path
// - download and install the puppet shaders from http://www.puppet.tfdv.com/download/shaders_p_e.shtml to use the new "pass final gather" - feature

// Version history:

// V0.1alpha:
// First preview release

// V0.11alpha (12.02.2004):
// - show details (Name/Author/Location) of selected SDR-File
// - delete previous setup
// - keylight is still cumbersome, but better
// - auto-set render globals
// - disable default light

// V0.12alpha (16.02.2004):
// - checks for env variable SDR for default directory

// V0.13alpha
// - scientific approach for keyLights
// - keyLights now work in MAYA 8.0 and above, too

// V0.14alpha
// - name revision: SDR is now called sIBL
// - added support for comments

// V0.141alpha
// - fixed a bug: folder names may now contain a -

// V0.15alpha (06.09.2007)
// - validate sIBL-Folder
// - add "/" after the folder name if the user has forgotten
// - env lighting is now possible via mental ray ibl-node
// - works now on MacOS X
// - matched scene orientation
// - light can cast shadows now

// V0.16alpha (05.03.2008)
// - script is now checking sIBL-Folder and filtering incorrect files
// - fixed glow-bug with MIA materials (thanks to mantered!)
// - added support for production shaders (thanks to Matt Estela!)

// V0.17alpha (20.10.2008)
// - added support for Maya 2008
// - fixed bug with ibl-sphere flipped and wrong rotations in Maya 2008 and above (thanks to Fexlex for reporting!)
// - added linear mode (thanks to Kel Solar!)
// - added support of the gamma parameters from the ibl - file, be aware that your renderings may look different now!
// - added function to pass on final gather (thanks to Filip Orrby!)


// Known Issues:
// - Key light doesn«t work properly
// - changing the sIBL-path crashes maya on macOS X
// - don«t use a background when rendering with mr-ibl or spheres for proper results,
//   if you want to use all components in one render pass download the puppet shaders and use the
//   function to "pass on final gather".

global proc loadSDR(string $filename)
{
    string $mySDR=`textFieldGrp -q -text Test`;
    string $fullPath = $mySDR + $filename + "/"; 
    // print ($fullPath + "\n");
    
    // Test: Verzeichnis durchsuchen
    string $FL[] = `getFileList -fld ($fullPath) -filespec "*.ibl"`;
    if (size($FL)!=0)  
        {
        string $filePath = $fullPath + $FL[0];
        $fileId = fopen($filePath,"r");
        if ($fileId!=0)
        {
            // check if sdr-file is valid
            string $nextWord = `fgetword $fileId`;
            if ($nextWord!="[Header]")
            {
                // this seems to be no sdr-file
                print ("sibl not valid\n");
                textScrollList -e -ri $filename tsl;
            }
            // check contentsourds
            // first disbale ...
            checkBox -e -en 0 -v 0 checkEnv;
            checkBox -e -en 0 -v 0 checkKeylight;
            checkBox -e -en 0 -v 0 checkRef;
            checkBox -e -en 0 -v 0 checkBack;
            while (!`feof $fileId`)
                {
                    string $nextWord = `fgetword $fileId`;
                    switch ($nextWord) {
                        case "[Sun]":
                        checkBox -e -en 1 checkKeylight;
                        break;
                        case "[Enviroment]":
                        checkBox -e -en 1 checkEnv;
                        break;
                        case "[Reflection]":
                        checkBox -e -en 1 checkRef;
                        break;
                        case "[Background]":
                        checkBox -e -en 1 checkBack;
                        break;
                        }
                }
            // rrrrreeewind
            frewind $fileId;
            // Search for ICOfile
            $nextWord = `fgetword  $fileId`;
            while ($nextWord!="ICOfile")
                {
                    $nextWord = `fgetword  $fileId`;
                }
            fgetword $fileId;
            string $filename = `fgetword $fileId`;
            string $buffer[];
            tokenize $filename "\"" $buffer;
            string $imageName = $fullPath + $buffer[0];
            //print $imageName;
   	        image -e -image $imageName refPic;
   	        
   	        /* Details */
   	        
   	        // get details from sdr-file
   	        $nextWord = `fgetword  $fileId`;
   	        
   	        // search for "Name"
   	        while (($nextWord!="Name")&&!`feof $fileId`)
   	        {
   	            $nextWord = `fgetword $fileId`;
   	        }
   	        // das = auslesen und wegschmeissen
   	        fgetword $fileId;
   	        // den Namen auslesen
   	        // ich will sicher gehen dass ich auch Namen, die aus mehreren Wörtern
   	        // bestehen, richtig lesen kann:
   	        string $puffer = `fgetword $fileId`;
   	        string $sdrName = $puffer;
   	        while (($puffer!="Author")&&!`feof $fileId`)
   	        {
   	            $puffer = `fgetword $fileId`;
   	            $sdrName = $sdrName + " " + $puffer;
   	        }
   	        // die Anfuehrungszeichen entfernen
   	        tokenize $sdrName "\"" $buffer;
   	        // $sdrName zuweisen
   	        $sdrName = "" + $buffer[0];
   	        
   	        // search for "Author"
   	        
   	        //while (($nextWord!="Author")&&!`feof $fileId`)
   	        //{
   	        //    $nextWord = `fgetword $fileId`;
   	        //
   	        // das = auslesen und wegschmeissen
   	        fgetword $fileId;
   	        // den Autorennamen auslesen
   	        $puffer = `fgetword $fileId`;
   	        string $aut = $puffer;
   	        while (($puffer!="Location")&&!`feof $fileId`)
   	        {
   	            $puffer = `fgetword $fileId`;
   	            $aut = $aut + " " + $puffer;
   	        }
   	        // die Anfuehrungszeichen entfernen
   	        tokenize $aut "\"" $buffer;
   	        // wieder $aut zuweisen
   	        $aut = "" + $buffer[0];
   	        
   	        // search for "Location"
   	        //while (($nextWord!="Location")&&!`feof $fileId`)
   	        //{
   	        //    $nextWord = `fgetword $fileId`;
   	        //}
   	        // das = auslesen und wegschmeissen
   	        fgetword $fileId;
   	        // den Locationnamen auslesen
   	        $puffer = `fgetword $fileId`;
   	    	string $loc = $puffer;
   	        while (($puffer!="Comment")&&!`feof $fileId`)
   	        {
   	            $puffer = `fgetword $fileId`;
   	            $loc = $loc + " " + $puffer;
   	        }
   	        // die Anfuehrungszeichen entfernen
   	        tokenize $loc "\"" $buffer;
   	        // wieder $loc zuweisen
   	        $loc = "" + $buffer[0];  	        
   	        
   	        // print ("Starting search, puffer:" + $puffer + "\n");
   	        // das = auslesen und wegschmeissen
   	        fgetword $fileId;
   	        string $comment = "";
   	        if	($puffer == "Comment")
   	        {
   	        	while ($puffer!="[Background]"&&!`feof $fileId`)
   	        	{
   	       			$puffer = `fgetword $fileId`;
   	        		// print ("Puffer:" + $puffer + "\n");
   	        		if ($puffer != "[Background]") $comment = $comment + " " + $puffer;
   	        	}
   	        }
   	        // die Anfuehrungszeichen entfernen
   	        tokenize $comment "\"" $buffer;
   	        $comment = $buffer[1];
   	        
   	        // Strings bauen
   	        string $nText = "Name:" + $sdrName;
   	        string $lText = "Location:" + $loc;
   	        string $aText = "Author:" + $aut;
   	        string $cText = "Comment:" + $comment;
   	        
   	        // Details anzeigen
   	        text -e -l $nText nameText;
   	        text -e -l $lText locationText;
   	        text -e -l $aText authorText;
   	        text -e -l $cText commentText;
   	        
   	        
        }   
   fclose($fileId);
    }
    else 
        {
        textScrollList -e -ri $filename tsl;
        }
} 

global proc load2SDR(string $filename)
{
    
    // check if I should delete the existing setup
    $delTest = `checkBox -q -v checkDel`;
    if ($delTest!=0)
    {
        select -cl;
        string $command = "ls \"SUN\*\"";
        string $selectionList[] = eval($command);
        if (size($selectionList)!=0)
        {
            select -add "SUN*";
        }
        string $command = "ls \"bg\*\"";
        string $selectionList[] = eval($command);
        if (size($selectionList)!=0)
        {
            select -add "bg*";
        }
        string $command = "ls \"refSphere_\*\"";
        string $selectionList[] = eval($command);
        if (size($selectionList)!=0)
        {
            select -add "refSphere_*";
        }
        string $command = "ls \"ENV_\*\"";
        string $selectionList[] = eval($command);
        if (size($selectionList)!=0)
        {
            select -add "ENV_*";
        }
        string $command = "ls \"env_\*\"";
        string $selectionList[] = eval($command);
        if (size($selectionList)!=0)
        {
            select -add "env_*";
        }
        string $command = "ls \"ref_\*\"";
        string $selectionList[] = eval($command);
        if (size($selectionList)!=0)
        {
            select -add "ref_*";
        }
        string $command = "ls \"ss_\*\"";
        string $selectionList[] = eval($command);
        if (size($selectionList)!=0)
        {
            select -add "ss_*";
        }
        
        string $iblNode[] = `ls -fl -typ mentalrayIblShape`;
        
        for ($iblNod in $iblNode)
        {
        	select -add $iblNod;
        	select -add (`listTransforms $iblNod`);
        }
        
        /*string $command = "ls \"mentalrayIbl\*\"";
        string $selectionList[] = eval($command);
        if (size($selectionList)!=0)
        {
            select -add "mentalrayIbl*";
        }
        // check for ibl-Node
        string $connectionPlug = `connectionInfo -sfd mentalrayGlobals.imageBasedLighting`;
        if ($connectionPlug != "")
        {
		string $tempo[];
		tokenize $connectionPlug "." $tempo;
		select -add $tempo[0];
	}*/
	   // select raySwitchStuff
	   string $rayStuff[] = `ls "raySwitch_*"`;
	   if (size($rayStuff)>0) select -add "raySwitch_*";
	   
	   
	   string $mipStuff[] = `ls "sIBL_rayswitch_*"`;
	   if (size($mipStuff)>0) select -add "sIBL_rayswitch_*";
	   
	   string $eyeGammaStuff[] = `ls "eyeGamma*"`;
	   if (size($eyeGammaStuff)>0) select -add "eyeGamma*";
	   
	   string $eyeGammaStuff[] = `ls "envGamma*"`;
	   if (size($eyeGammaStuff)>0) select -add "envGamma*";
	   
	   string $eyeGammaStuff[] = `ls "refGamma*"`;
	   if (size($eyeGammaStuff)>0) select -add "refGamma*";
	   
	   // select lens shader
	   string $lensShader[] = `ls -fl -typ mia_exposure_simple`;
	   for ($lS in $lensShader)
	   {
	   	select -add $lS;
	   }
	   
	   // delete puppet shader and mip_continue
	   select -add `ls "REF_mc_*"`;
	   select -add `ls "REF_prt_*"`;
	   select -add `ls "BG_mc_*"`;
	   select -add `ls "BG_prt_*"`;
	   
	   
        string $Selected[] = `ls -sl`;
        if (size($Selected)!=0)
        {
        delete;
        }

   }
   	
   	//check if I should display textures
    $texTest = `checkBox -q -v checkTex`;
    if ($texTest==1)
    {
        DisplayShadedAndTextured;
    }
   	
   	//check if I should set render globals
   	$renTest = `checkBox -q -v checkRen`;
   	if ($renTest==1)
   	{
   	    setAttr defaultRenderGlobals.currentRenderer -type "string" mentalRay;
   	    updateRendererUI();
            setAttr "miDefaultOptions.finalGather" 1;
            setAttr "miDefaultOptions.maxSamples" 1;
            setAttr "miDefaultOptions.minSamples" -1;
            setAttr "miDefaultOptions.jitter" 1;
    }
    
    //disable default light
    setAttr "defaultRenderGlobals.enableDefaultLight" 0;
    
    string $mySDR=`textFieldGrp -q -text Test`;
    string $fullPath = $mySDR + $filename + "/"; 
    
    // Test: Verzeichnis durchsuchen
    string $FL[] = `getFileList -fld $fullPath -filespec "*.ibl"`;
    string $filePath = $fullPath + $FL[0];
    $fileId = fopen(($filePath),"r");
    if ($fileId!=0)
    {    
   	    string $nextWord = `fgetword $fileId`;
   	    
   	    // check for raySwitch
   	    $rayTest = `checkBox -q -v checkRaySwitch`;
   	    if ($rayTest!=0)
   	    {
   	    // create raySwitch setup
   	    string $raySwitchSphere[] = `polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 1 -ch 1 -n ("raySwitch_" + $filename)`;
   	    string $raySwitchShape[]= `listRelatives -s $raySwitchSphere[0]`;
   	    
   	    scale -r -50 50 50;
   	    rotate -r 0 108 0;
   	    
   	    while($nextWord!="BGfile"&&!`feof $fileId`)
        {
            $nextWord = `fgetword $fileId`;
        }
            fgetword $fileId;
            string $BGfile= `fgetword $fileId`;
            string $buffer[];
            tokenize $BGfile "\"" $buffer;
            string $bgFile = encodeString($fullPath) + $buffer[0];
            string $surfaceShader = `shadingNode -asShader surfaceShader -name ("raySwitch_" + $filename)`;
            string $surfaceSG = ` sets -renderable true -noSurfaceShader true -empty -name ($surfaceShader + "SG")`;
            connectAttr -f ($surfaceShader + ".outColor")  ($surfaceSG + ".surfaceShader");
            sets -e -fe $surfaceSG $raySwitchSphere[0];
            
            string $mrs = `shadingNode -asShader mip_rayswitch -n ("sIBL_rayswitch_" + $filename)`;
            
            connectAttr -f ($mrs + ".outValue") ($surfaceSG + ".miMaterialShader");
            
            // suppress maya shaders
            setAttr ($surfaceSG + ".miExportMrMaterial") 1;
            
            // check if background is enabled
   	        $backTest = `checkBox -q -v checkBack`;
   	        
   	        if ($backTest!=0)
   	        {  
   	            // connect bgFile to the lambert for reference only
                string $fileNode = `shadingNode -at file -name ("bg_" + $filename)`;
                setAttr -type "string" ($fileNode + ".fileTextureName") ($bgFile);
                connectAttr -f ($fileNode + ".outColor") ($surfaceShader + ".outColor");
                
                // connect bgFile
                string $eyeGamma = `shadingNode -asUtility gammaCorrect -name ("eyeGamma_" + $filename)`;
                connectAttr -f ($fileNode + ".outColor") ($eyeGamma + ".value"); 
                connectAttr -f ($eyeGamma + ".outValue") ($mrs + ".eye");
                
                // check for linear mode
             	$linTest = `checkBox -q -v checkLin`;
             	if ($linTest!=0) 
             	{
             		setAttr ($eyeGamma + ".gammaX") 0.4545;
             		setAttr ($eyeGamma + ".gammaY") 0.4545;
             		setAttr ($eyeGamma + ".gammaZ") 0.4545;
             	}
                
                // get selected resolution
                string $resStr[] = `textScrollList -q -si resTSL`;
                int $res = (int) $resStr[0]; 
                // set texture resolution
                addAttr -ln resolution -at long -dv $res $surfaceShader;
            }
            
            // search for EVfile
            while ($nextWord!="EVfile"&&!`feof $fileId`)
            {
                $nextWord = `fgetword $fileId`;
            }
            fgetword $fileId;
            string $EVfile = `fgetword $fileId`;
            string $buffer[];
            tokenize $EVfile "\"" $buffer;
                        
            // search for EVmulti
            while ($nextWord!="EVmulti"&&!`feof $fileId`)
            { 
                $nextWord = `fgetword $fileId`;
            }
                       
            fgetword $fileId;
            string $EVmulti = `fgetword $fileId`;
            float $EVmult = (float) $EVmulti;
            
            
            // search for EVgamma
	    while ($nextWord!="EVgamma"&&!`feof $fileId`)
	    { 
	    	$nextWord = `fgetword $fileId`;
	    }
	                           
	    fgetword $fileId;
	    string $EVgammaStr = `fgetword $fileId`;
            float $EVgamma = (float) $EVgammaStr;
                        
            $envTest = `checkBox -q -v checkEnv`;
            if ($envTest!=0)
            {
                // create env texture and connect it
                string $fileNode =`shadingNode -at file -name ("env_" + $filename)`;
                string $envTex = encodeString($fullPath) + $buffer[0];
                setAttr -type "string" ("env_" + $filename + ".fileTextureName")  $envTex;
                setAttr -type "double3" ($fileNode + ".colorGain") $EVmult $EVmult $EVmult;
              	
              	string $envGamma = `shadingNode -asUtility gammaCorrect -name ("envGamma_" + $filename)`;
		connectAttr -f ($fileNode + ".outColor") ($envGamma + ".value"); 
                connectAttr -f ($envGamma + ".outValue") ($mrs + ".finalgather");
                
                // check for linear mode
		$linTest = `checkBox -q -v checkLin`;
		if ($linTest!=1) 
			{
		       	setAttr ($envGamma + ".gammaX") $EVgamma;
		      	setAttr ($envGamma + ".gammaY") $EVgamma;
		      	setAttr ($envGamma + ".gammaZ") $EVgamma;
             	}
            }
            
            //search for REFfile
            while($nextWord!="REFfile" &&!`feof $fileId`)
            {
                $nextWord = `fgetword $fileId`;
            }
            fgetword $fileId;
            string $REFfile = `fgetword $fileId`;
            string $REFbuffer[];
            tokenize $REFfile "\"" $REFbuffer;
               
            //search for REFmulti
            while($nextWord!="REFmulti" &&!`feof $fileId`)
            {
                $nextWord = `fgetword $fileId`;
            }
            fgetword $fileId;
            string $REFMulti = `fgetword $fileId`;
            float $REFmult = (float) $REFMulti;
            
            //search for REFgamma
	    while($nextWord!="REFgamma" &&!`feof $fileId`)
	    {
	        $nextWord = `fgetword $fileId`;
	    }
	    fgetword $fileId;
	    string $REFgammaStr = `fgetword $fileId`;
            float $REFgamma = (float) $REFgammaStr;
            
            $refTest = `checkBox -q -v checkRef`;
            if ($refTest!=0)
            {
               string $refNode = `shadingNode -at file -name ("ref_" + $filename)`;
               string $refTex = encodeString($fullPath) + $REFbuffer[0];
               // set image path
               setAttr -type "string" ($refNode + ".fileTextureName") $refTex;
               setAttr -type "double3" ($refNode + ".colorGain") $REFmult $REFmult $REFmult;
               string $refGamma = `shadingNode -asUtility gammaCorrect -name ("refGamma_" + $filename)`;
	       connectAttr -f ($refNode + ".outColor") ($refGamma + ".value");
               connectAttr -f ($refGamma + ".outValue") ($mrs + ".reflection"); 
               
               // check for linear mode
	       $linTest = `checkBox -q -v checkLin`;
	       if ($linTest!=1) 
	       	{
	      		setAttr ($refGamma + ".gammaX") $REFgamma;
	       		setAttr ($refGamma + ".gammaY") $REFgamma;
	       		setAttr ($refGamma + ".gammaZ") $REFgamma;
             	}
            }
            
            
   	    }
   	    else
   	    { 
   	        // check if background is enabled
   	        $backTest = `checkBox -q -v checkBack`;
   	        if ($backTest!=0)
   	        {  
   	            //create backgroundSphere
   	            // Nurbs sphere: 
   	            // sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 60 -d 3 -ut 0 -tol 0.01 -s 14 -nsp 8 -ch 1;
   	            polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 1 -ch 1;
   	            rename ("bgSphere_" + $filename);
                //scale -r 50 50 50 ;
                // Stefan und Volks Weg: Anpassen der Umgebungskugeln
                scale -r -50 50 50;
                rotate -r 0 108 0;
                
                
                string $Selected[] = `ls -sl`;
                // set bg-sphere attributes
                 string $command = "setAttr bgSphere_" + $filename + ".castsShadows 0";
                 eval($command);
                 $command = " setAttr bgSphere_" + $filename + ".receiveShadows 0";
                 eval($command);
                $command = "setAttr bgSphere_" + $filename + ".motionBlur 0";
                eval($command);
                // turn off primaryVisibility so the bg is not included in final gather
                $command = "setAttr bgSphere_" + $filename + ".primaryVisibility 0";
                eval($command);
                $command = "setAttr bgSphere_" + $filename + ".visibleInReflections 0";
                eval($command);
                $command = "setAttr bgSphere_" + $filename + ".visibleInRefractions 0";
                eval($command);
                $command = "setAttr bgSphere_" + $filename + ".doubleSided 0";
                eval($command);
                setAttr ("bgSphere_" + $filename + ".opposite") 1;
                // setAttr ("bgSphere_" + $filename + ".miFinalGatherCast") 0;
                // setAttr ("bgSphere_" + $filename + ".miFinalGatherReceive") 0;
                
                
                // !!!
                // string $command = "setAttr " + $bgSphere + ".rotateX 180";
                // eval($command);
                //search for BGfile
                while($nextWord!="BGfile"&&!`feof $fileId`)
                    {
                        $nextWord = `fgetword $fileId`;
                    }
                 fgetword $fileId;
                 string $BGfile= `fgetword $fileId`;
                 string $buffer[];
                 tokenize $BGfile "\"" $buffer;
                 string $bgFile = encodeString($fullPath) + $buffer[0];
                 string $bgFileNode = `shadingNode -at file -name ("bg_" + $filename)`;
                 string $command = "setAttr -type \"string\" bg_" + $filename + ".fileTextureName \"" + $bgFile + "\" \"image\"";
                 //string $command = "AEassignTextureCB bg_" + $filename + ".fileTextureName \"" + $bgFile + "\" \"image\"";
                 eval ($command);
                 $command = "shadingNode -asShader surfaceShader";
                 eval($command);
                 $command = "rename bgSs_" + $filename;
                 eval($command);
                 string $bgShadingGroup = `sets -renderable true -noSurfaceShader true -empty -name ("bgSs_" + $filename + "SG")`;
                 $command = "select -r " + $Selected[0];
                 eval($command);
                 refreshAE;
                 connectAttr -f ("bgSs_" + $filename + ".outColor") ($bgShadingGroup + ".surfaceShader");
                 $command = "connectAttr -f bg_" + $filename + ".outColor bgSs_" + $filename + ".outColor";
                 eval($command);
                 $command = "sets -e -forceElement bgSs_" + $filename + "SG;";
                 eval($command);
                 //$command = " AEnewInt \"bgSs_" + $filename + ".resolution\" \"Resolution\" \"512\" ";
                 
                 
                 // get selected resolution
                 string $resStr[] = `textScrollList -q -si resTSL`;
                 int $res = (int) $resStr[0]; 
                 // set texture resolution
                 $command = "addAttr -ln resolution -at long -dv " + $res + " bgSs_" + $filename;
                 eval($command);
                 refreshAE;
                 $command = "setAttr \"bgSs_" + $filename + ".outMatteOpacity\" -type double3 0 0 0";
                 eval($command);
                 
                 
                 // check for puppet
                 $puppetTest = `checkBox -q -v checkPuppet`;
                 if ($puppetTest!=0)
                 {
                 	setAttr ($bgShadingGroup  + ".miExportMrMaterial") 1;
                 	string $bgPRT = `shadingNode -asShader p_ray_type -name ("BG_prt_" + $filename)`;
                 	connectAttr -f ($bgPRT + ".outValue") ($bgShadingGroup + ".miMaterialShader");
                 	connectAttr -f ($bgFileNode + ".outColor") ($bgPRT + ".eye");
               		connectAttr -f ($bgFileNode + ".outAlpha") ($bgPRT + ".eyeA");
               		setAttr ($bgPRT +".enable_finalgather") 1;
               		string $bgMc = `createNode mib_continue -name ("BG_mc_"+ $filename)`;
               		connectAttr -f ($bgMc + ".outValue") ($bgPRT + ".finalgather");
                 }
                 
                 
            }
            
            
            // %%%%%%%%%%%%%%%%%%%%%%%
            // check if env is enabled
            // %%%%%%%%%%%%%%%%%%%%%%%
            
            $envTest = `checkBox -q -v checkEnv`;
            if ($envTest!=0)
            {
                // check for sphere instead of ibl-node
                int $sphereTest = `checkBox -q -v checkGeo`;
                if ($sphereTest!=0)
                {
                    // create ENV-sphere
                    // default env-sphere
                    //sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 30 -d 3 -ut 0 -tol 0.01 -s 14 -nsp 8 -ch 1;
                    polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 1 -ch 1;
                    //scale -r 51 51 51 ;
                    // Stefan und Volks Weg: Anpassen der Umgebungskugeln
                    scale -r -51 51 51 ;
                    rotate -r 0 108 0;
                
                    rename ("ENV_" + $filename);
                    pickWalk -d down;
                        string $Selected[] = `ls -sl`;
                        string $esName = $Selected[0];
                        //refreshAE;
                        // set env-sphere attributes
                        setAttr ($esName + ".castsShadows") 0;
                        setAttr ($esName + ".receiveShadows") 0;
                setAttr ($esName + ".motionBlur") 0;
                        setAttr ($esName + ".primaryVisibility") 0;
                        setAttr ($esName + ".smoothShading") 0;
                        setAttr ($esName + ".visibleInReflections") 0;
                setAttr ($esName + ".visibleInRefractions") 1;
                setAttr ($esName + ".doubleSided") 0;
                        setAttr ($esName + ".opposite") 1;
            
                    // search for EVfile
                    while ($nextWord!="EVfile"&&!`feof $fileId`)
                         {
                             $nextWord = `fgetword $fileId`;
                         }
                    fgetword $fileId;
                    string $EVfile = `fgetword $fileId`;
                    string $buffer[];
                    tokenize $EVfile "\"" $buffer;
                        
                    // search for EVmulti
                      while ($nextWord!="EVmulti"&&!`feof $fileId`)
                      { 
                            $nextWord = `fgetword $fileId`;
                       }
                       
                        fgetword $fileId;
                        string $EVmulti = `fgetword $fileId`;
                        float $EVmult = (float) $EVmulti;
                        
                    // search for EVgamma
		       while ($nextWord!="EVgamma"&&!`feof $fileId`)
		       { 
		       		$nextWord = `fgetword $fileId`;
		       }
		                           
		       fgetword $fileId;
		       string $EVgammaStr = `fgetword $fileId`;
                       float $EVgamma = (float) $EVgammaStr;
                        
                    // create texture
                       string $fileNode =`shadingNode -at file -name ("env_" + $filename)`;
                       string $envTex = encodeString($fullPath) + $buffer[0];
                       string $command = "setAttr -type \"string\" env_" + $filename + ".fileTextureName \"" + $envTex + "\" \"image\"";
                           eval($command);
                           // create shader
                           $command = "shadingNode -asShader surfaceShader";
                           eval($command);
                           $command = "rename ss_" + $filename;
                           eval($command);
                           // create shading group
                           $command = "sets -renderable true -noSurfaceShader true -empty -name ss_" + $filename + "SG";
                           eval ($command);
                           // select sphere
                           $command = "select -r " + $Selected[0];
                           eval($command);
                           refreshAE;
                           // connect shader to shading group
                           $command = "connectAttr -f ss_" + $filename + ".outColor ss_" + $filename + "SG.surfaceShader";
                           eval($command);
                           // assign
                           $command = "sets -e -forceElement ss_" + $filename + "SG;";
                           eval($command);
                           // create gamma
                           string $envGamma = `shadingNode -asUtility gammaCorrect -name ("envGamma_" + $filename)`;
			   connectAttr -f ("env_" + $filename + ".outColor") ($envGamma + ".value");
			   
			   // connect texture
                           connectAttr -f ($envGamma + ".outValue") ("ss_" + $filename + ".outColor"); 
                          
                          setAttr -type "double3" ($fileNode + ".colorGain") $EVmult $EVmult $EVmult;
                          
                          // check for linear mode
			  $linTest = `checkBox -q -v checkLin`;
			  if ($linTest!=1) 
			  {
			   	setAttr ($envGamma + ".gammaX") $EVgamma;
				setAttr ($envGamma + ".gammaY") $EVgamma;
				setAttr ($envGamma + ".gammaZ") $EVgamma;
			  }
                          
                          
            }
            else
            {
                // create ibl-node
		miCreateIbl;                
            	string $connectionPlug = `connectionInfo -sfd mentalrayGlobals.imageBasedLighting`;
            	string $tempo[];
            	tokenize $connectionPlug "." $tempo;
            	string $iblNode = $tempo[0];
            
            // get transform
             string $iblTransform[] = `listTransforms $iblNode`;
            setAttr ($iblTransform[0] + ".scaleX") -51; 
            setAttr ($iblTransform[0] + ".scaleY") 51;
            setAttr ($iblTransform[0] + ".scaleZ") 51;
            // setAttr ($iblTransform[0] + ".rotateY") 108;
            
            // set ibl to texture 
            setAttr ($iblNode + ".type") 1
            ;
            // get env-texture and set it 
            // search for EVfile
            while ($nextWord!="EVfile"&&!`feof $fileId`)
            {
                $nextWord = `fgetword $fileId`;
            }
            fgetword $fileId;
            string $EVfile = `fgetword $fileId`;
            string $buffer[];
            tokenize $EVfile "\"" $buffer;                  
            string $envTex = encodeString($fullPath) + $buffer[0];
            
            // search for EVmulti
            while ($nextWord!="EVmulti"&&!`feof $fileId`)
            {
                $nextWord = `fgetword $fileId`;
            }
            fgetword $fileId;
            string $EVmulti = `fgetword $fileId`;
            float $EVmult = (float) $EVmulti;
            
            // search for EVgamma
	    while ($nextWord!="EVgamma"&&!`feof $fileId`)
	    { 
	    	$nextWord = `fgetword $fileId`;
            }
	    		                           
	    fgetword $fileId;
	    string $EVgammaStr = `fgetword $fileId`;
            float $EVgamma = (float) $EVgammaStr;
            
            string $envFile = `shadingNode -at file -n ("env_" + $filename)`;
            setAttr -type "string"($envFile + ".fileTextureName") $envTex;
            
            // create gamma
	    string $envGamma = `shadingNode -asUtility gammaCorrect -name ("envGamma_" + $filename)`;
	    connectAttr -f ($envFile + ".outColor") ($envGamma + ".value");
            connectAttr -f ($envGamma + ".outValue") ($iblNode + ".color");
            
            // check for linear mode
	    $linTest = `checkBox -q -v checkLin`;
	    if ($linTest!=1) 
	    {
	    	setAttr ($envGamma + ".gammaX") $EVgamma;
	    	setAttr ($envGamma + ".gammaY") $EVgamma;
	    	setAttr ($envGamma + ".gammaZ") $EVgamma;
	    }
            
            setAttr -type "double3" ($iblNode + ".colorGain") $EVmult $EVmult $EVmult;
            
            select -cl;
            
             }
        }
            
            // $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
            // check if reflection is enabled
            // $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
            
            $refTest = `checkBox -q -v checkRef`;
            if ($refTest!=0)
            {   
                polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 1 -ch 1;
                rename ("refSphere_" + $filename);
                scale -r -52 52 52 ;
                rotate -r 0 108 0;
                string $Selected[] = `ls -sl`;
                string $refSphere = $Selected[0];
                    
                // set ref-sphere attributes
                 string $command = " setAttr " + $refSphere + ".castsShadows 0";
                 eval($command);
                $command = " setAttr " + $refSphere + ".motionBlur 0";
                eval($command);
                $command = "setAttr " + $refSphere + ".receiveShadows 0";
                eval($command);
                $command = " setAttr " + $refSphere + ".primaryVisibility 0";
                eval($command);
                $command = " setAttr " + $refSphere + ".doubleSided 0";
                eval($command);
                $command = " setAttr " + $refSphere + ".visibleInRefractions 1";
                eval($command);
                $command = " setAttr " + $refSphere + ".visibleInReflections 1";
                eval($command);
                $command = " setAttr " + $refSphere + ".opposite 1";
                eval($command); 
                //search for REFfile
                while($nextWord!="REFfile" &&!`feof $fileId`)
                    {
                        $nextWord = `fgetword $fileId`;
                    }
               fgetword $fileId;
               string $REFfile = `fgetword $fileId`;
               string $REFbuffer[];
               tokenize $REFfile "\"" $REFbuffer;
               
                //search for REFmulti
                while($nextWord!="REFmulti" &&!`feof $fileId`)
                    {
                        $nextWord = `fgetword $fileId`;
                    }
               fgetword $fileId;
               string $REFMulti = `fgetword $fileId`;
               float $REFmult = (float) $REFMulti;
               
               // search for REFgamma
	       while ($nextWord!="REFgamma"&&!`feof $fileId`)
	            { 
	       	    	$nextWord = `fgetword $fileId`;
	       	    }                    
	       fgetword $fileId;
	       string $REFgammaStr = `fgetword $fileId`;
               float $REFgamma = (float) $REFgammaStr;
               
               // creating texture for reflections
               
               string $refNode = `shadingNode -at file -name ("ref_" + $filename)`;
               string $refTex = encodeString($fullPath) + $REFbuffer[0];
               // set image path
               string $command = "setAttr -type \"string\" ref_" + $filename + ".fileTextureName \"" + $refTex + "\" \"image\"";
               eval($command);
               // create shader
               $command = "shadingNode -asShader surfaceShader -n ref_ss_" + $filename;
               // print($command);
               eval($command);
               // create shadingGroup
               string $refShadingGroup = `sets -renderable true -noSurfaceShader true -empty -name ("ref_ss_" + $filename + "SG")`;
               // print($command);
               eval($command);
               // select reflection sphere
               $command = "select -r refSphere_" + $filename;
               eval($command);
               // connect shader to shading Group
               $command = "connectAttr -f ref_ss_" + $filename + ".outColor ref_ss_" + $filename + "SG.surfaceShader";
               eval($command);
               // assign
               $command = "sets -e -forceElement ref_ss_" + $filename + "SG;";
               eval($command);
               
               // create gamma
	       string $refGamma = `shadingNode -asUtility gammaCorrect -name ("refGamma_" + $filename)`;
	       connectAttr -f ($refNode + ".outColor") ($refGamma + ".value");
	       			   
	       // connect texture
               connectAttr -f ($refGamma + ".outValue") ("ref_ss_" + $filename + ".outColor");
	       
	       // check for linear mode
	       $linTest = `checkBox -q -v checkLin`;
	       if ($linTest!=1) 
	       {
	     		setAttr ($refGamma + ".gammaX") $REFgamma;
	       		setAttr ($refGamma + ".gammaY") $REFgamma;
	       		setAttr ($refGamma + ".gammaZ") $REFgamma;
	       }
               
               setAttr -type "double3" ($refNode + ".colorGain") $REFmult $REFmult $REFmult;
               
               select -cl;
               
               // check for puppet
	       $puppetTest = `checkBox -q -v checkPuppet`;
	       if ($puppetTest!=0)
	       {
	       		setAttr ($refShadingGroup  + ".miExportMrMaterial") 1;
	            	string $refPRT = `shadingNode -asShader p_ray_type -name ("REF_prt_" + $filename)`;
	                connectAttr -f ($refPRT + ".outValue") ($refShadingGroup + ".miMaterialShader");
	                connectAttr -f ($refGamma + ".outValue") ($refPRT + ".eye");
	                connectAttr -f ($refNode + ".outAlpha") ($refPRT + ".eyeA");
	                setAttr ($refPRT + ".enable_finalgather") 1;
	                string $refMc = `createNode mib_continue -name ("REF_mc_"+ $filename)`;
	                connectAttr -f ($refMc + ".outValue") ($refPRT + ".finalgather");
               }
   	    }
   	    }
   	       
   	    
   	    //"""""""""""""""""""""""""
   	    // check if sun is enabled
   	    //"""""""""""""""""""""""""   	    
   	    $sunTest = `checkBox -q -v checkKeylight`;
   	    if ($sunTest!=0)
   	    {
   	        // search for sunColor
   	        while($nextWord!="SUNcolor"&&!`feof $fileId`)
   	            {
   	                $nextWord = `fgetword $fileId`;
   	            }
   	        fgetword $fileId;
   	        string $sunColorString = `fgetword $fileId`;
   	        string $sunColorRGB[];
   	        tokenize $sunColorString "," $sunColorRGB;

            // search for sunIntensity
            while($nextWord!="SUNmulti"&&!`feof $fileId`)
                {
                    $nextWord = `fgetword $fileId`;
                }
             fgetword $fileId;
             string $sunIntensity= `fgetword $fileId`;
   	        
   	        // search for sunU
   	        while($nextWord!="SUNu"&&!`feof $fileId`)
   	            {
   	            $nextWord = `fgetword $fileId`;
   	            }
   	        fgetword $fileId;
   	        $sunU = `fgetword $fileId`;
   	        
   	        // search for sunV
   	        while($nextWord!="SUNv"&&!`feof $fileId`)
   	            {
   	            $nextWord = `fgetword $fileId`;
   	            }
   	        fgetword $fileId;
   	        $sunV = `fgetword $fileId`;
   	        
   	        // calculate rotation
   	        // method 1:
   	        //$sunRotY = cos(float($sunU)*360);
            //$sunRotX = cos((float($sunV)-0.5)*90);  
            //$sunRotZ = cos(float($sunU)*360);
            // method 2:
            //$sunRotX = sin(float($sunU)*360);
            //$sunRotY = cos((float($sunV)-0.5)*90);
            //$sunRotZ = cos(float($sunU)*360);
            // createLight
            // method 3:
            //--sZ = sin((0.5 - SUNy)*180)   -- Z is height! 
            //--dR = cos((0.5 - SUNy)*180) 
            //--sX = (cos(SUNx*360)) * dR   -- X is left right 
            //--sY = (sin(SUNx*360)) * dR   -- Y is front back 
            //$sunRotY = sin((0.5-float($sunV))*180);
            //$dr = cos((0.5 -float($sunV))*180);
            //$sunRotX = (cos(float($sunU) * 360))* $dr;
            //$sunRotZ = (sin(float($sunU)*360))* $dr;
            
            // neuer Versuch
            //$tx = sin(deg_to_rad((float)$sunU * 360)) * 6; 
            //$ty = cos(deg_to_rad((float)$sunV - 0.5) * 90) * 6; 
            //$tz = cos(deg_to_rad((float)$sunU * 360)) * 6;
            
            //Intensitaet des Lichts runter schrauben
            //TODO: Find out why this is necessary
            float $lightInt = float($sunIntensity)/200;
            
            // old version: defaultDirectionalLight differs in parameters between Maya 7.0 and 8.0
            // defaultDirectionalLight($lightInt, float($sunColorRGB[0]),float($sunColorRGB[1]),float($sunColorRGB[2]), "0", 0,0,0, 0);
            string $lightName = `shadingNode -asLight spotLight`;
            $lightName = `rename $lightName ("SUN_" + $filename)`;
            setAttr ($lightName + ".intensity") $lightInt;
            setAttr ($lightName + ".colorR") (float($sunColorRGB[0]));
            setAttr ($lightName + ".colorG") (float($sunColorRGB[1]));
            setAttr ($lightName + ".colorB") (float($sunColorRGB[2]));
            setAttr ($lightName + ".coneAngle") 90;
            
            int $test = `checkBox -q -v checkShadows`;
            
            if ($test==1) setAttr ($lightName + ".useRayTraceShadows") 1;
            
            // just Rotate
            // $sunRotY = 360 - ((float) $sunU * 360);
            // $sunRotX = atan($tx/$tz);
            // $srX = rad_to_deg($sunRotX);
            // $srY = $sunRotY ;
            //$srZ = rad_to_deg($sunRotZ);
            
            
            // translate
            move -r -os -wd 0 0 48 ;
            

            string $adjustGroup = `group -w -n ($lightName + "_adjustGroup")`;
            xform -os -piv 0 0 0;
            rotate -r -os -90 0 0;
            
            pickWalk -d down;
            
            string $rotateV = `group -n ($lightName + "_rotateV")`;
            xform -os -piv 0 0 0;
            string $rotateU = `group -n ($lightName + "_rotateU")`;
            xform -os -piv 0 0 0;
                        
            float $rotV = (float) $sunV * 180.0;
            
            float $rotU = (float) $sunU * 360.0;
            
            setAttr ($rotateV + ".rotateX") $rotV;
            setAttr ($rotateU + ".rotateZ") (-$rotU);
            
            select -cl;
            
            //Version von Stefan und Volk
            // $srX = 90 - (180 -  ((float)$sunV * 180));
            // $srY = 90 + ((float)$sunU * 360);
            
            // true scientific way
            // float $theta = ((float) $sunU + 0.5)* 6.283184;
            // float $phi = (float) $sunV * 3.141592;
            
            // float $srZ = rad_to_deg (cos($theta) * sin($phi) * -1);
            // float $srY = rad_to_deg (cos($phi));
            // float $srX = rad_to_deg (sin($theta) * sin($phi) * -1);
       
       	    // rotate 180 Degrees first
       	    // rotate -r -os 180 0 0;
       	   
            // rotate -r -os 0 0 $srZ;
            // print ("Rotating " + $srZ + " in Z!\n");
            // rotate -r -os 0 $srY 0;
            // print ("Rotating " + $srY + " in Y!\n");
            // rotate -r -os $srX 0 0;
            // print ("Rotating " + $srX + " in X!\n");
            
            //scale -r 1 1 -1 ;
            
            
   	        
   	    }
   	    
   	    //"""""""""""""""""""""""""
	    // check if linear workflow is selected
   	    //""""""""""""""""""""""""" 
   	    $linTest = `checkBox -q -v checkLin`;
   	    if ($linTest!=0)
   	    {
   	    	// create mental ray lens shader
   	    	string $lin_lenseShader = `createNode "mia_exposure_simple"`;
   	    	$lin_lenseShader = `rename ($lin_lenseShader) ("sIBL_" + $filename + "_mia_exosure_simple")`;
   
   	    	// connect lense shader to all cameras
   	    	string $cameraList[] = `ls -fl -type "camera"`;
   	    	for ($cam in $cameraList)
   	    	{
   	    		connectAttr -f ($lin_lenseShader + ".message") ($cam + ".miLensShader");
   	    	}
   	    	
   	    	
   	    	
   	    }
   	    
   	    
   	    fclose($fileId);
   	} 
   	select -cl;
}

global proc enterPath(string $mySDR,string $message)
{
	print("Please define an Environmentvariable sIBL pointing to your collection...");
       	string $window = `window -title "Set collection path..."
    	-iconName "Short Name"
    	-widthHeight 200 100`;
       	columnLayout -adjustableColumn true;
     	text -label $message;
      	textFieldGrp
	-label "sIBL collection path:"
 	-text $mySDR
    	-editable true
   	-cc "$mySDR = `textFieldGrp -q -text Test2`"    
    	Test2;
        button -label "OK" 
        -command ("string $mySDR = `textFieldGrp -q -text Test2`;deleteUI -window " + $window + ";" + "sIBL2($mySDR)");
       	setParent ..;
      	showWindow $window;
}

// Interface

global proc sIBL()
{
     // make sure mentalrayOptions exist
        if(! `objExists miDefaultOptions`)
            {
            	string $mro = `createNode mentalrayOptions  -n miDefaultOptions`;
            	dgdirty $mro;
        	}
        if(! `objExists mentalrayGlobals`)
        	{
        		createNode mentalrayGlobals -n mentalrayGlobals;
        	}
    select -r mentalrayGlobals;
    // Directory with the default sIBL-Library
    string $mySDR="C:/sIBL/Library/";
    string $envTest=`getenv "sIBL"`;
    if ($envTest!="")
        {
            $mySDR = $envTest;
            sIBL2($mySDR);
        }
        else enterPath($mySDR,"There is no environment variable sIBL defined! Please enter your Collection Path!");
    // this is necessary for Maya 2008 and below
    string $sourceCMRT = "source createMentalRayGlobalsTab.mel";
    if (`exists createMentalRayGlobalsTab.mel`) catchQuiet (eval ($sourceCMRT));
    // this is necessary for Maya 2009
    string $sourceCMRILT = "source createMentalRayIndirectLightingTab.mel";
    if (`exists createMentalRayIndirectLightingTab.mel`) catchQuiet (eval ($sourceCMRILT));
}
    
// starting sdr2 with an argument

global proc sIBL2(string $mySDR)
{   
    // check if user forgot the last "/" and add it if he did
    int $letterCount = size($mySDR);
    if ((!endsWith($mySDR,"/"))&&(!endsWith($mySDR,"\\"))) $mySDR = $mySDR + "/";
    
    // Load the SDR-List
    
    // print ("mySDR:" + $mySDR + "!");
    
    string $Temp_List[] = `getFileList -folder $mySDR`; 
    
    // check if files are folders
    int $Temp_count = size($Temp_List);
    int $SDR_count = 0;
    string $SDR_List[];
    for ($i=0; $i<$Temp_count; $i++)
    {
        // check if there are any ibl-files in the folder
        string $IBL_List[] = `getFileList -fs ("*.ibl") -fld ($mySDR + "/" + $Temp_List[$i] + "/")`;
        $iblFile = $IBL_List[0];
        for ($iblTest in $IBL_List)	
        {
        	int $iblCheck = `strcmp $iblTest ($Temp_List[$i] + "*.ibl")`;
        	if ($iblCheck==0) $iblFile = $iblTest;
        }
        // print ($iblTest + "\n");
        catchQuiet ($testFileId = `fopen ($mySDR + "/" + $Temp_List[$i] + "/" + $iblTest) "r"`);
        // print ($testFileId + "\n");
        if ($testFileId!=0) 
        {
            $SDR_List[$SDR_count] = $Temp_List[$i];
            $SDR_count++;
        }
        fclose $testFileId;  
    }
    
    
    // empty help string
    print "";
    // check if SDR_List is empty
    int $slCount = size ($SDR_List);
    if  ($slCount==0) 
    {
    	enterPath($mySDR,"This Folder does not contain any sIBL-sets. Please enter a new folder...");
    }
    else
    {
    	// Evironment-Variable aktualisieren
    	putenv "sIBL" $mySDR;

    	// Create Window   
		if ((`window -ex sIBL_Window`) == 1) 
        {
            deleteUI -window sIBL_Window;
            // print ("Deleted old Window!\n");
        }
		window -title "sIBL Loader v0.17a" -menuBar true -s true -widthHeight 440 500 sIBL_Window;
		// print ("Creating new window!");
		setUITemplate -pst attributeEditorTemplate;
    	string $form = `formLayout -numberOfDivisions 100`;
    	string $cL = `columnLayout `;
    	    rowColumnLayout -numberOfColumns 2 -columnWidth 1 300 -columnWidth 2 128;
    	    textFieldGrp
 				    -label "SIBL-Collection path:"
 				    -text  $mySDR
    			    -editable false
    			    -cc "$mySDR = `textFieldGrp -q -text Test`;sIBL2($mySDR);"    
    			     Test;
    	    button -label "Change path ..." -c "textFieldGrp -e -editable true Test";
    	// Schleife, um die Entries zu erzeugen
		int $length = size($SDR_List);
		
		string $command = "textScrollList -numberOfRows " + 8 + " -allowMultiSelection false";
		int $i=0;
		for ($i=0; $i<$length; $i++)
		{
    	$command = $command + " -append " + $SDR_List[$i];
		}
		$command = $command + " -selectItem " + $SDR_List[0];
		$command = $command + " -sc \"string $selName[] = `textScrollList -q -si tsl`;loadSDR($selName[0]);\" tsl";
		eval ($command);
		// print($mySDR);
		image -image ($mySDR + "sIBLmaya.jpg") -h 124 refPic;
		// Spalte fuer die Optionen
		columnLayout;
    	checkBox -label "create background" -en 1 checkBack;
    	checkBox -label "create environment map" -en 1 checkEnv;
    	checkBox -label "create reflection map" -en 1 checkRef;
    	checkBox -label "create key light" -en 1 checkKeylight;
   	
    	// zum uebergeordneten Layout wechseln
		setParent..;
		// Spalte fuer die Detailinformationen
		columnLayout;
		text -label "Name:" nameText;
		text -label "Location:" locationText;
    		text -label "Author:" authorText;
	
    	// zum uebergeordneten Layout wechseln
		setParent..;
		setParent..;
		text -label "Comment:" commentText;
		rowColumnLayout -numberOfColumns 2 -columnWidth 1 300 -columnWidth 2 128;
    	button -label "Load selected" -c "string $selName[] = `textScrollList -q -si tsl`;load2SDR($selName[0]);";
		formLayout -e -attachForm $cL "top" 5 -attachForm $cL "bottom" 30 $form;
		
		//load default selection
		loadSDR($SDR_List[0]);
		
		text -label "" dummyText;
		// checkBox: will ich das bestehende Setup loeschen?
		checkBox -label "delete previous sIBL-setup" -en 1 checkDel;
		
		// checkBox: set Render Globals
		checkBox -label "set render globals" -en 1 checkRen;
		
		// checkBox: create geometry sphere for environment map
		checkBox -label "use sphere instead of ibl-node" -en 0 checkGeo;
		
		// add command for environment sphere
		checkBox -e -cc "int $cE = `checkBox -q -v checkEnv`; checkBox -e -en $cE checkGeo;" checkEnv;
		
		// add command for keylight
		checkBox -e -cc "int $cE = `checkBox -q -v checkKeylight`; checkBox -e -en $cE checkShadows;" checkKeylight;
		
        // checkBox: cast shadows
		checkBox -label "cast shadows" -en 0 checkShadows;
		
        // checkBox: use rayswitch (requires Maya 2008 or above)
		checkBox -label "use rayswitch (requires Maya 2008 or above)" -en 1 checkRaySwitch;
		
		checkBox -label "linear workflow" -en 1 checkLin;
		
		// checkBox: show Textures in Viewport
		checkBox -label "show textures at resolution -> " -en 1 checkTex;
    	
        		textScrollList -numberOfRows 1 -allowMultiSelection false
		    -ann "set resolution to" -append "512"      -append "1024"      -append "2048"
		    -append "4096"
		    -selectItem "512"
    		    -showIndexedItem 1 resTSL;
    
    		checkBox -label "pass on final gather (requires puppet shaders)" -en 1 checkPuppet;
    		
    		// add command for rayswitch
		checkBox -e -cc "int $cRS = `checkBox -q -v checkRaySwitch`; int $cE= `checkBox -q -v checkEnv`; if ($cRS==0) checkBox -e -en 1 checkPuppet; if ($cRS==0 && $cE==1) checkBox -e -en 1 checkGeo; if ($cRS==1) { checkBox -e -en 0 checkGeo; checkBox -e -en 0 checkPuppet; }" checkRaySwitch;
		
    	setParent..;	
	    // print ("\nFinished, now what?");
		// print ($SDR_List[0]);
		// select first sIBL in column
		textScrollList -e -si $SDR_List[0] tsl;
		showWindow sIBL_Window;
		// print ("Showing Window...");
	}
}